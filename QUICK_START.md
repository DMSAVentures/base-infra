# Quick Start: Add a New App in 5 Minutes

## Prerequisites
- Domain added to Cloudflare
- AWS ECR repository created for your API

## Step-by-Step

### 1. Edit `apps.tf`

Add your app to the `locals.apps_config` block:

```hcl
mynewapp = {
  domain         = "mynewapp.com"
  api_port       = 8081              # Increment from last app
  api_image_repo = "mynewapp-server"
  database_name  = "mynewapp_db"
  cpu            = 256
  memory         = 256
  env_secrets    = {}                # Add custom secrets if needed
}
```

### 2. Apply Infrastructure

```bash
terraform plan
terraform apply
```

**That's it!** Terraform automatically creates:
- ✅ S3 bucket + CloudFront
- ✅ ACM certificate + DNS validation
- ✅ Database credentials (SSM)
- ✅ ECS container configuration
- ✅ ALB routing rules
- ✅ Cloudflare DNS records

### 3. Get Outputs

```bash
terraform output apps_summary
```

This shows:
- CloudFront distribution domain
- S3 bucket name
- API port
- Target group ARN

### 4. Create Database

```bash
# Get credentials
DB_USER=$(aws ssm get-parameter --name "/mynewapp/db/username" --with-decryption --query "Parameter.Value" --output text)
DB_PASS=$(aws ssm get-parameter --name "/mynewapp/db/password" --with-decryption --query "Parameter.Value" --output text)
DB_ENDPOINT=$(aws ssm get-parameter --name "/mynewapp/db/endpoint" --query "Parameter.Value" --output text)

# Connect and create database
psql -h $DB_ENDPOINT -U <MASTER_USER> -d postgres -c "CREATE DATABASE mynewapp_db;"
psql -h $DB_ENDPOINT -U <MASTER_USER> -d postgres -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';"
psql -h $DB_ENDPOINT -U <MASTER_USER> -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE mynewapp_db TO $DB_USER;"
```

### 5. Deploy API

```bash
# Build and push to ECR
docker build -t mynewapp-server .
docker tag mynewapp-server:latest $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com/mynewapp-server:latest
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com
docker push $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com/mynewapp-server:latest

# Force new ECS deployment
aws ecs update-service --cluster ecs-cluster --service multi-app-api-service --force-new-deployment
```

### 6. Deploy Webapp

```bash
# Build Vite app
npm run build

# Get S3 bucket name
BUCKET=$(terraform output -json apps_summary | jq -r '.mynewapp.s3_bucket')

# Upload
aws s3 sync dist/ s3://$BUCKET --delete

# Invalidate CloudFront
DIST_ID=$(terraform output -json apps_summary | jq -r '.mynewapp.cloudfront_distribution_id')
aws cloudfront create-invalidation --distribution-id $DIST_ID --paths "/*"
```

### 7. Verify

```bash
# Check ECS task is running
aws ecs describe-services --cluster ecs-cluster --services multi-app-api-service

# Test API
curl https://mynewapp.com/api/health

# Test webapp
curl https://mynewapp.com
```

## Routing Verification

Your app will ONLY receive requests matching:
- **Host**: `mynewapp.com`, `www.mynewapp.com`, or `*.mynewapp.com`
- **Path**: `/api/*`

All other requests return 404. This prevents API misdirection.

## Troubleshooting

### API returns 404
- Wait 2-3 minutes for CloudFront to propagate
- Check ALB listener rules: `aws elbv2 describe-rules --listener-arn $(terraform output -raw alb_listener_arn)`
- Verify container is healthy: `aws ecs describe-tasks --cluster ecs-cluster --tasks $(aws ecs list-tasks --cluster ecs-cluster --service multi-app-api-service --query 'taskArns[0]' --output text)`

### Container won't start
- Check logs: `aws logs tail /mynewapp/api --follow`
- Verify image exists in ECR
- Check environment variables in task definition

### Database connection fails
- Verify RDS security group allows ECS security group
- Test connection from ECS instance: `psql -h $DB_ENDPOINT -U $DB_USER -d mynewapp_db`

## Environment Variables

Your API container automatically receives:

```bash
# Database
DB_HOST=<rds-endpoint>
DB_NAME=mynewapp_db
DB_USERNAME=<from-ssm>
DB_PASSWORD=<from-ssm>

# App config
SERVER_PORT=8081
GO_ENV=production
GIN_MODE=release
JWT_SECRET=<auto-generated>
WEBAPP_URI=https://mynewapp.com
GOOGLE_REDIRECT_URI=https://mynewapp.com/auth/callback

# Your custom secrets (from env_secrets)
...
```

## Next App

To add another app, just repeat with a different port:

```hcl
app3 = {
  domain         = "app3.io"
  api_port       = 8082        # Next port!
  api_image_repo = "app3-api"
  database_name  = "app3_db"
  cpu            = 256
  memory         = 256
  env_secrets    = {}
}
```

Run `terraform apply` again. That's it!
